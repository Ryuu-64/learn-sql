# 索引

### **聚集索引（CLUSTERED INDEX）**

- 定义：聚集索引决定了表的物理数据存储顺序。每个表只能有一个聚集索引。
- 特点：叶子节点包含实际的数据行，因此查询时可以直接访问数据，无需回表。
- 创建方式：通过 `CREATE CLUSTERED INDEX` 语句创建。

### **非聚集索引（NONCLUSTERED INDEX）**

- 定义：非聚集索引与表的数据存储顺序分离。叶子节点包含的是索引键和指向数据行的指针。
- 特点：
  - 非聚集索引的叶子节点中存储的是索引键和数据行的指针（行标识符）。
  - 可以创建多个非聚集索引，每个索引可以覆盖不同的查询列，但需要回表操作来访问实际数据。
- 创建方式：通过 `CREATE NONCLUSTERED INDEX` 语句创建。

### **复合索引（Composite Index）**

- 定义：复合索引是一个包含多个列的索引。它可以加速涉及多个列的查询。

- 特点：

  - 适用于查询中涉及多个列的情况。
  - 索引列的顺序可能会影响查询优化的效果。

- 示例：

  ```sql
  CREATE INDEX idx_name_age ON employees(name, age);
  ```

### **覆盖索引（Covering Index）**

- 定义：覆盖索引是一种特殊类型的索引，它包含查询所需的所有列数据。因此，当查询使用覆盖索引时，数据库可以直接从索引中返回结果，而无需回表操作来检索实际的数据行。
- 特点：
  - 覆盖索引可以是非聚集索引，也可以是聚集索引。关键点在于索引中包含了查询中所有需要的列。
  - 通过包含所有相关列，覆盖索引能够避免回表，从而提高查询效率。

#### **覆盖索引和其他索引的关系**

##### **聚集索引可以是覆盖索引**

如果聚集索引你包含了查询中的所有的列，则这个聚集索引是一个覆盖索引。因为数据本身存储在聚集索引的叶子节点中，查询可以直接用过该索引获取所有需要的数据，无需回表。

```sql
CREATE CLUSTERED INDEX idx_name ON employees(name, age); // 创建聚集索引
```

对于查询：

```sql
SELECT name, age FROM employees WHERE name = 'Bob';
```

聚集索引 `idx_name` 包含查询需要的所有列（`name` 和 `age`），所以这个聚集索引是一个覆盖索引

##### **非聚集索引可以是覆盖索引**

一个非聚集索引可以被设计成覆盖索引，只要它包含查询所需的所有列数据。例如，如果你有一个非聚集索引包含了查询中所有的列（包括筛选条件和需要返回的列），那么这个非聚集索引就是一个覆盖索引。

示例：

假设有一个表 `employees`，包含 `id`, `name` 和 `age` 列。我们经常执行查询 `SELECT age FROM employees WHERE name = 'Bob';`。为了优化这个查询，我们可以创建一个覆盖索引。

**在 SQL Server 中创建覆盖索引**：

```sql
CREATE NONCLUSTERED INDEX idx_name_age ON employees(name) INCLUDE (age);
```

解释：

- `idx_name_age` 是索引的名称。
- `name` 是索引的键列。
- `INCLUDE (age)` 指定了额外的包含列，使得 `age` 列的数据也包含在索引中。

这样，当查询 `SELECT age FROM employees WHERE name = 'Bob';` 被执行时，SQL Server 可以直接使用 `idx_name_age` 索引来获取 `age` 列的值，而无需回表操作。这个非聚集索引在这种情况下就成了覆盖索引。

### **唯一索引（Unique Index）**

- 定义：唯一索引是一种特殊的非聚集索引，确保索引列中的每个值都是唯一的，不允许重复值。

- 特点：

  - 可以用于一个或多个列。
  - 自动对索引列的数据进行唯一性验证。
  - 对应的索引类型可以是聚集索引或非聚集索引。

- 示例：

  ```sql
  CREATE UNIQUE INDEX idx_unique_name ON employees(name);
  ```

### 其他

#### **创建带有包含列的索引**

以 SQL Server 为例

 通过包含非键列，可以创建覆盖更多查询的非聚集索引。 这是因为非键列具有下列优点：

- 它们可以是不允许作为索引键列的数据类型。
- 在计算索引键列数或索引键大小时，数据库引擎不考虑它们。

**当索引包含查询引用的所有列时，它通常称为“覆盖查询”。**

##### 设计建议

- 重新设计索引键大小较大的非聚集索引，以便只有用于搜索和查找的列为键列。 使覆盖查询的所有其他列成为非键列。 这样，将具有覆盖查询所需的所有列，但索引键本身较小，而且效率高。
- 将非键列包含在非聚集索引中，以避免超过当前索引大小的限制（最大键列数为 32，最大索引键大小为 1,700 字节，而在 SQL Server 2016 (13.x) 以前，最大键列数为 16，最大索引键大小为 900 字节）。 数据库引擎计算索引键列数或索引键大小时，不考虑非键列。
- 索引定义中非键列的顺序不会影响使用该索引的查询的性能。
- 避免使用非常宽泛的非聚集索引，其中的包含列不代表一个足够窄小的基础表列的子集。 如果添加宽泛索引，务必验证更新一个额外的宽泛索引的成本是否抵消了直接从表中读取的成本。

##### 限制和局限

- 只能对非聚集索引定义非键列。
- 除了 **text**、 **ntext** 和 **image** 之外的所有数据类型都可以用作非键列。
- 精确或不精确的确定性计算列都可以是非键列。 有关详细信息，请参阅[计算列索引](https://learn.microsoft.com/zh-cn/sql/relational-databases/indexes/indexes-on-computed-columns?view=sql-server-ver16)。
- 只要允许将计算列数据类型作为非键索引列，从 **image**、 **ntext**和 **text** 数据类型派生的计算列就可以作为非键索引列。
- 除非先删除某一表的索引，否则无法从该表中删除非键列。
- 除进行下列更改外，不能对非键列进行其他更改：
  - 将列的为空性从 NOT NULL 改为 NULL。
  - 增加 **varchar**、 **nvarchar** 或 **varbinary** 列的长度。

[create-indexes-with-included-columns](https://learn.microsoft.com/zh-cn/sql/relational-databases/indexes/create-indexes-with-included-columns?view=sql-server-ver16)